#

## TCP/IP

IPv4的头部结构长度为20字节，若含有可变长的选项部分，最多60字节

### TCP 粘包/拆包

## UDP

### UDP报文长度多大？

![udp](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png)

**UDP数据包最大长度？**
由于报文长度字段为 16 字节，因此 UDP 报文理论上可以达到 ，也就是 65535 字节。除去头部，UDP 包最多可以承载的数据量是：2^16 - 8 ，也就是 65527 字节。

但 UDP 报文需要作为数据，搭载在 IP 包中进行网际通信。因此，UDP 报文大小最多也就是 IP 包的最大长度 65535 字节。换句话讲，UDP 报文长度不可能超过 ，也就是(理想长度) 65507 字节。其中，20 是 IP 包头部的最小长度。

当然啦，一个数据包能否发送65507字节，还和UDP发送缓冲区大小（**linux下UDP发送缓冲区大小为：cat /proc/sys/net/core/wmem_default）相关**，如果发送缓冲区小于65507字节，在发送一个数据包为65507字节的时候，send或sendto函数会错误码1(Operation not permitted， No buffer space available)。

**UDP数据包理想长度**

其实一个标准的以太网数据帧大小是：1518，**头信息有14字节，尾部校验和FCS占了4字节**，所以真正留给上层协议传输数据的大小就是：1518 - 14 - 4 = 1500，

**数据链路层** 最大传输单元是 **1500 字节**(MTU) ，要想 IP 层不分包，那么**UDP 数据包**的最大大小应该是1500字节 – IP头(20字节) – UDP头(8字节) = **1472字节。**

#### 分片问题

### UDP数据包的发送和接收问题

**(1) UDP的通信有界性**
在阻塞模式下，UDP的通信是以数据包作为界限的，即使server端的缓冲区再大也要按照client发包的次数来多次接收数据包，server只能一次一次的接收，client发送多少次，server就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。

**(2) UDP数据包的无序性和非可靠性。**
client依次发送1、2、3三个UDP数据包，server端先后调用3次接收函数，可能会依次收到3、2、1次序的数据包，收包可能是1、2、3的任意排列组合，也可能丢失一个或多个数据包。

**(3) UDP数据包的接收。**

client发送两次UDP数据，第一次 500字节，第二次300字节，server端阻塞模式下接包，第一次recvfrom( 1000 )，收到是 1000，还是500，还是300，还是其他？

* 由于UDP通信的有界性，接收到只能是500或300，又由于UDP的无序性和非可靠性，接收到可能是300，也可能是500，也可能一直阻塞在recvfrom调用上，直到超时返回(也就是什么也收不到)。

在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，server端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？

* 由于UDP通信的有界性，第一次recvfrom( 200)将接收第一个500字节的数据包，但是因为用户空间buf只有200字节，于是只会返回前面200字节，剩下300字节将丢弃。第二次recvfrom( 1000)将返回300字节，第三次recvfrom( 1000)将会阻塞。

如果 MTU 是1500，Client 发送一个 8000字节大小的 UDP 包，那么 Server 端阻塞模式下接包，在不丢包的情况下，recvfrom(9000) 是收到 1500，还是 8000。如果某个 IP 分片丢失了，recvfrom(9000)，又返回什么呢？

* 根据 UDP 通信的有界性，在 buf 足够大的情况下，接收到的一定是一个完整的数据包，UDP 数据在下层的**分片和组片问题由 IP 层来处理**，提交到 UDP 传输层一定是一个完整的 UDP 包，那么 recvfrom(9000) 将返回 8000。如果某个 IP 分片丢失，udp 里有个 CRC 检验，**如果包不完整就会丢弃**，也不会通知是否接收成功，所以 UDP 是不可靠的传输协议，那么 recvfrom(9000) 将阻塞。

分片分的越多，虽然在传输层都是一次 send，一次 recv ，但在传输过程中，会传输多次，那么丢包的概论就越大，如何解决丢包问题呢？

### UDP 有发送缓存区吗？

每个 UDP socket 都**有一个接收缓冲区**，**没有发送缓冲区**，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，所以不缓冲，不需要发送缓冲区。

UDP：当套接口接收缓冲区满时，新来的数据报无法进入接收缓冲区，此数据报就被丢弃。UDP是没有流量控制的；快的发送者可以很容易地就淹没慢的接收者，导致接收方的 UDP 丢弃数据报。

且，如果在传输过程中，一次传输被分成多个分片，传输中有一个小分片丢失，那接收端最终会舍弃整个文件，导致传输失败，这就是 UDP 不可靠的原因。

<https://cloud.tencent.com/developer/article/1004554>
<https://www.toutiao.com/article/7184328775239205380/?&source=m_redirect&wid=1710297735306>

## TCP为什么是三次握手？不是两次、四次？

* 三次握手才可以阻止重复历史连接的初始化（主要原因）
* 三次握手才可以同步双方的初始序列号
* 三次握手才可以避免资源浪费

### 原因一：避免历史连接

三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱。**

我们考虑一个场景，客户端先发送了 SYN（seq = 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100）报文（**注意！不是重传 SYN，重传的 SYN 的序列号是一样的**）。

看看三次握手是如何阻止历史连接的：
![tcp](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png)

客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在网络拥堵情况下：

* 一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文中的确认号是 91（90+1）。
* 客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回 RST 报文。
* 服务端收到 RST 报文后，就会释放连接。
* 后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。

上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的**最主要原因就是防止「历史连接」初始化了连接。**

如果是两次握手连接，就无法阻止历史连接，**那为什么 TCP 两次握手为什么无法阻止历史连接呢？**

主要是因为在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。

你想想，在两次握手的情况下，服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。

![s](https://cdn.xiaolincoding.com//mysql/other/fe898053d2e93abac950b1637645943f.png)
可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。

因此，要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。

所以，TCP 使用三次握手建立连接的**最主要原因是防止「历史连接」初始化了连接。**

### 原因二：同步双方初始序列号

TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：

* 接收方可以去除重复的数据；
* 接收方可以根据数据包的序列号按序接收；
* 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；

可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样一来一回，才能确保双方的初始序列号能被可靠的同步。**

![a](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230639121.png)

四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。

而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

### 原因三：避免资源浪费

如果只有「两次握手」，当客户端发生的 SYN 报文在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，**由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接，** 这会造成什么情况呢？

如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。**

![a](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230636571.png)

即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 SYN 报文，而造成重复分配资源。

### 小结

TCP 建立连接时，通过三次握手**能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。** 序列号能够保证数据包不重复、不丢弃和按序传输。

不使用「两次握手」和「四次握手」的原因：

* 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
* 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

## 三次握手丢失？

### 第一次丢失？

  客户端会重传，到达重传次数还没收到服务端第二次握手，就断开连接。

### 第二次丢失？

两端都会进行重传。超过最大重传次数时:

* 客户端未收到第二次握手，就断开连接
* 服务端因为没有收到第三次握手，就断开连接

### 第三次握手丢失？

**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。**

服务端重新发送第二次握手，超过最大的次数，服务端就断开连接。

但是此时，**客户端已经显示，已经建立好连接了**，客户端在往服务端发送数据时，会携带ACK,服务端会返回RST报文中断连接。

## 四次挥手？

![](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

* 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
* 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

从上面过程可知，**服务端通常需要等待完成数据的发送和处理**，所以服务端的 ACK 和 FIN 一般都会分开发送，因此是需要四次挥手。

### 第一次挥手丢失了，会发生什么？

如果第一次挥手丢失了，那么**客户端**迟迟收不到被动方的 ACK 的话，也就**会触发超时重传机制**。

超过重传次数时，**就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍）**，如果还是没能收到第二次挥手，那么**直接进入到 close**状态。

### 第二次挥手丢失了，会发生什么？

**ACK 报文是不会重传的**，所以如果服务端的第二次挥手丢失了，**客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数**。

超过重传次数时，**就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍）**，如果还是没能收到第二次挥手，那么**直接进入到 close**状态。

### 第三次挥手丢失了，会发生什么？

* 当服务端重传第三次挥手报文的次数达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。
* **客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的**，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么**客户端就会断开连接**。

### 第四次挥手丢失了，会发生什么？

* 当**服务端重传**第三次挥手报文**达到了最大重传次数**，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么**服务端就会断开连接**。

* **客户端在收到第三次挥手后**，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，**当等待 2MSL 时长后，客户端就会断开连接。**

### 为什么 TIME_WAIT 等待的时间是 2MSL？

MSL 是 Maximum Segment Lifetime，报文最大生存时间，**它是任何报文在网络上存在的最长时间**，超过这个时间报文将被丢弃。

### 四次挥手的第二三次是否能合并,既然能合并，为什么不都合并?

当被动关闭方（上图的服务端）在 TCP 挥手过程中，「没有数据要发送」并且「**开启了 TCP 延迟确认机制**」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。

#### 什么是  TCP 延迟确认机制？

当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。

为了解决 ACK 传输效率低问题，所以就衍生出了 TCP 延迟确认。

TCP 延迟确认的策略：

* 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
* 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
* 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK

ack和syn是不同时机触发的  **ack是内核完成,会在收到fin的时候第一时间返回**  而**fin则是应用程序代码块控制,在调用到socket的close方法才会触发fin**

## 为什么需要 TIME_WAIT 状态？

需要 TIME-WAIT 状态，主要是两个原因：

* **防止历史连接中的数据，被后面相同四元组的连接错误的接收；**
  * 序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。
* 保证「被动关闭连接」的一方，能被正确的关闭；
  * **等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。**

**(1) 可靠地实现TCP全双工连接的终止；
(2) 允许老的重复分节在网络中消逝。**

## 服务器出现大量 TIME_WAIT 状态的原因有哪些？

首先**要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态**，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明**服务器主动断开了很多 TCP 连接**。

### 问题来了，什么场景下服务端会主动断开连接呢？

* 第一个场景：HTTP 没有使用长连接
* 第二个场景：HTTP 长连接超时
* 第三个场景：HTTP 长连接的请求数量达到上限

根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，**都是由服务端主动关闭连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。**

## 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？

**CLOSE_WAIT 状态是「被动关闭方」才会有的状态**，而且如果 「被动关闭方」**没有调用 close 函数**关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。

**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。**

我们先来分析一个普通的 TCP 服务端的流程：

1. 创建服务端 socket，bind 绑定端口、listen 监听端口
2. 将服务端 socket 注册到 epoll
3. epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket
4. 将已连接的 socket 注册到 epoll
5. epoll_wait 等待事件发生
6. 对方连接关闭时，我方调用 close

可能导致服务端没有调用 close 函数的原因，如下：

### 第一个原因 : 没有将服务端 socket 注册到 epoll

第 2 步没有做，**没有将服务端 socket 注册到 epoll**，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了

不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。

### 第二个原因:没有调用 accpet 获取该连接的 socket

 第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。

### 第三个原因:没有将其注册到 epoll

第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。

发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。

### 第四个原因 : 服务端没有执行 close 函数

第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等

## 为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？

主要原因是为了防止历史报文被下一个相同四元组的连接接收。

## 在 TCP 正常挥手过程中，处于 TIME_WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么？

如果双方开启了时间戳机制：

* 如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要大，并且SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要大。那么就会重用该四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。
* 如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要小，或者SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要小。那么就会再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号，就回 RST 报文给服务端。

在 TIME_WAIT 状态，收到 RST 会断开连接吗？

* 如果 net.ipv4.tcp_rfc1337 参数为 0，则提前结束 TIME_WAIT 状态，释放连接。
* 如果 net.ipv4.tcp_rfc1337 参数为 1，则会丢掉该 RST 报文。

## TCP 连接，一端断电和进程崩溃有什么区别？

### 如果客户端的「主机崩溃」了，会发生什么?

客户端主机崩溃了，服务端是无法感知到的，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。

### 进程崩溃

即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。

### 客户端主机宕机，又迅速重启

在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发超时重传机制，重传未得到响应的报文。

服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：

* 如果客户端主机上没有进程绑定该 TCP 报文的目标端口号，那么客户端内核就会回复 RST 报文，重置该 TCP 连接；
* 如果客户端主机上有进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会回复 RST 报文，重置该 TCP 连接。

**所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。**

### 客户端主机宕机，一直没有重启

这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。

### 总结  

如果「客户端进程崩溃」，客户端的进程在发生崩溃的时候，内核会发送 FIN 报文，与服务端进行四次挥手

但是，「客户端主机宕机」，那么是不会发生四次挥手的，具体后续会发生什么？还要看服务端会不会发送数据？

* 如果服务端会发送数据，由于客户端已经不存在，收不到数据报文的响应报文，服务端的数据报文会超时重传，当重传总间隔时长达到一定阈值（内核会根据 tcp_retries2 设置的值计算出一个阈值）后，会断开 TCP 连接；
* 如果服务端一直不会发送数据，再看服务端有没有开启 TCP keepalive 机制？
  * 如果有开启，服务端在一段时间没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；
  * 如果没有开启，服务端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态。

## 拔掉网线后， 原本的 TCP 连接还存在吗？

客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。

有数据传输的情况：

* 在客户端拔掉网线后，如果服务端发送了数据报文，那么在**服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在**，就好像什么事情都没有发生。
* 在客户端拔掉网线后，**如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接**。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以**就会回 RST 报文**，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。
  
没有数据传输的情况：

* 如果**双方都没有开启 TCP keepalive 机制**，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么**客户端和服务端的 TCP 连接状态将会一直保持存在。**
* 如果**双方都开启了 TCP keepalive 机制**，那么在客户端拔掉网线后，如果客户端一直不插回网线，**TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接**。而如果在 TCP **探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。**

## 浏览器输入url后会发生什么（这个题被问了好多次）

1. 浏览器从地址栏的输入中解析URL，获取web服务器的IP地址和端口号
1. 浏览器通过三次握手与web服务器建立TCP连接
1. 浏览器发送HTTP请求报文，这个报文会依次加上TCP头，IP头，MAC头，组成一个完整的数据包
1. 数据包经过网卡转换为电信号，在网线上传输，中途要经过很多交换机和路由器
1. 经过路由器时，路由器会查询路由表来确定下一跳的IP，一直转发到与目标IP同一网段的路由器
1. 这个路由器会查ARP表获取目标IP服务器的MAC地址，然后通过某个端口转发给web服务器
1. web服务器收到数据包后，会依次拆开MAC头，IP头，TCP头，然后把HTTP请求报文发给监听指定端口的服务端进程
1. 服务端进程收到请求报文后处理请求，然后发送响应报文给浏览器
1. 浏览器收到后解析响应报文，渲染输出页面

## 长连接和短连接的区别，各自使用场景？

### 前提

* HTTP/1.0默认使用短连接，HTTP/1.1开始默认使用长连接；
* HTTP协议的长连接和短连接，实质就是TCP协议的长连接和短连接；
* TCP协议建立连接需要3次握手，断开连接需要4次握手，这个过程会消耗网络资源和时间；

### 定义

1. 长连接：在一个TCP连接上可以发送多个数据包，但是如果没有数据包发送时，也要双方发检测包以维持这个长连接； 三次握手后连接，不断开连接，保持客户端和服务端通信，直到服务器超时自动断开连接，或者客户端主动断开连接。
2. 短连接：当双方需要数据交互的时候，就建立一个TCP连接，本次交互完之后就断开这个连接；三次握手后建立连接，发送数据包并得到服务器返回的结果后，通过客户端和服务器的四次握手后断开连接。

### 优缺点

1. 长连接可以省去较多建立连接和断开连接的操作，所以比较节省资源和时间，但是长连接如果一直存在的话，需要很多探测包的发送来维持这个连接，这对服务器将是很大的负担；
2. 相对而言，短连接不需要服务器承担太大负担，只要存在的连接就是有用的连接，但如果客户端请求频繁，就会在TCP的建立连接和断开连接上浪费较大的资源和时间。

### 使用场景

1. 短连接：适用于网页浏览等数据刷新频度较低的场景。一般而言像及京东，淘宝这些大型网站，随时都会有成千上万的用户请求，一般使用短连接，用户量太大，服务器扛不住那么多长连接；
2. 长连接：适用于客户端和服务端通信频繁的场景，例如：聊天室，实时游戏等场景。即时通讯（QQ）般使用的都是长连接，但并不是永久连接（比如20分钟，半个小时），因为即时通讯是频繁的发送请求，使用长连接只需要建立一次连接，同时再根据业务设置保持时间，超过这个时间就会断开连接，一定程度上保证了服务器的压力不会过大。

## http和https的区别

* HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
* HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
* 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
* HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
* https其实是一种**对称加密和非对称加密混合通信的**
  * 在建立连接时，第一次采用非对称加密，客户端用网站发布的私钥对应的公钥将自己的公钥进行加密，发送至网站，网站用私钥进行解密，然后后面的通信都会用这个公钥进行对称加密。
  * 断开连接后，这次使用的公钥就会销毁，下次连接时，会生成新的的公钥。

### 对称加密

对称加密是指，双使用同一个加密公钥，来进行通信。

就像之前进行，加密时，用同一套加密本一样。

### 非对称加密

A向B发送信息时，A会用B的公钥进行加密，B在接受信息时，用自己的私钥进行解密。

注意:
这里会出现一个问题，如果黑客，将B的公钥换为黑客自己的公钥，A发送出去信息，再被黑客截取到，那么黑客就用自己的私钥来解密，就会获取A发送的信息。

### 添加 CA 证书

CA(certificate authority)机构就是证书授权中心。会把用户的公钥做一个认证，证明A B 的公钥是被认证过的，是正确的。

CA会把A的公钥用自己的私钥去签一个名，就证明公钥被我验证过了。CA会把签名过的数据发布到网上，就叫做证书。然后通过官方的渠道下载。

**怎么确认是不是官方的？**
我们电脑里会有CA机构的公钥，拿公钥去验签一下，是不是真的。

刚开始 我向 CA 这里去查看 B 的公钥，这里就保证 B 的公钥是正确的，不会被篡改。

## TCP如何保证可靠传输? 重要

### 校验和

TCP是端到端的传输，由发送方计算校验和，接收方进行验证，目的是为了验证TCP首部和数据在发送过程中没有任何改动，一旦发现校验和有差错，直接丢弃TCP段并重新发送。

### 序列号/确认应答

TCP传输时发送方对每一个发送的消息都会编号，也就是序列号seq。接收方在每次接收到消息后回复确认应答号ACK，不仅告诉接收到哪些数据，还包括下一次消息从哪里发送。只要发送方没有接收到确认应答号ACK，都会重新发送数据。

### 超时重传

发送方发送完数据后会等待一定的时间，如果在这个时间内没有接收到ACK，就会重传数据。如果是发送方发生了丢包，那么接收方在接收到数据后会回复ACK，如果是接收方回复的ACK丢失了导致的重传，那么根据校验和和序列号知道该数据已经接收，丢弃该数据并发送ACK。

### 连接管理

三次握手和四次挥手得以实现。

### 流量控制（滑动窗口控制）

发送方发送数据的快慢取决于接收方接收能力。TCP的报文信息中有一个16位字段来标识滑动窗口，窗口大小就是接收方剩余缓冲区大小，在回复ACK时，接收方将自己剩余缓冲区大小填入。发送方根据窗口大小来调整自己的发送速度，如果缓冲区大小为0，那么发送方会停止发送数据。并且发送方定期会发送探测报文，来获取缓冲区大小。

### 快速重传

当接收端收到比期望号大的seq时候，就会发送冗余ACK，在超时重传之前如果收到三个相同的冗余ACK，那么就知道哪段报文发生了丢包，重传该段报文即可，避免了超时重传。

### 拥塞控制

网络可能刚开始很拥塞，如果在网络传输过程中开始就发送大量数据的话，会发生丢包和超时重传，所以需要慢启动算法、拥塞避免算法、快速重传和快速恢复。

慢启动算法

一开始不发送大量数据，而是应该先发一小部分探测数据，然后由小到大逐渐增大发送窗口。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为1，每次接收到报文之后将窗口大小翻倍。如果指数增长到避免拥塞算法的门限ssthresh，则改用避免拥塞算法。

初始化设置 cwnd = 1，并开始传输数据
收到回馈的 ACK，会将 cwnd 加 1
当发送端一个 RTT 后且未发现有丢包重传，就会将 cwnd = cwnd * 2
当 cwnd >= ssthresh 或发生丢包重传时慢启动结束，进入拥塞避免状态

### 避免拥塞算法

每当收到一个 ACK 时，cwnd 增加 1/cwnd，变为线性增长。一但发现丢包和超时重传，就进入拥塞处理状态。

### 拥塞发生

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：超时重传和快速重传。

ssthresh 和 cwnd 的值会发生变化

ssthresh 设为 cwnd/2
cwnd 重置为 1
发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：

cwnd = cwnd/2 ，也就是设置为原来的一半
ssthresh = cwnd
进入快速恢复算法

### 快速恢复

拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）
重传丢失的数据包
如果再收到重复的 ACK，那么 cwnd 增加 1
如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态

## TCP拥塞控制

* 慢启动
  * **当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**
  * 发包的个数是**指数性的增长**。
  * 有一个叫**慢启动门限 ssthresh**（slow start threshold）状态变量。
  * 当 cwnd(拥塞窗口) < ssthresh 时，使用慢启动算法。
  * 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。

* 拥塞避免
  * **每当收到一个 ACK 时，cwnd (拥塞窗口)增加 1/cwnd。**
  * 线性增长。
* 拥塞发生
  * 当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：
  * 超时重传
    * 当发生了「超时重传」，则就会使用拥塞发生算法。
  
      这个时候，ssthresh 和 cwnd 的值会发生变化：
      * ssthresh 设为 cwnd/2，
      * cwnd 重置为 1 （**是恢复为 cwnd 初始化值**，我这里假定 cwnd 初始化值 1）
    * 这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。
  * 快速重传
    * 当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。
    * TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh(慢启动门限) 和 (拥塞窗口)cwnd 变化如下：
      * cwnd = cwnd/2 ，也就是设置为原来的一半;
      * ssthresh = cwnd;
      * 进入快速恢复算法

* 快速恢复
  * 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
  * 重传丢失的数据包；
  * 如果再收到重复的 ACK，那么 cwnd 增加 1；
  * 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

## IP

### 网络层与数据链路层有什么关系呢？

MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。
